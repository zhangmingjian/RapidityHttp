using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Rapidity.Http.Attributes;
using Rapidity.Http.Extensions;
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Rapidity.Http.DynamicProxies
{
    /// <summary>
    /// https://stackoverflow.com/questions/37526165/compiling-and-running-code-at-runtime-in-net-core-1-0
    /// https://benohead.com/three-options-to-dynamically-execute-csharp-code/
    /// </summary>
    public static class ProxyGenerator
    {
        public static Assembly Generate(Type[] types)
        {
            var template = BuildTemplate(types);
            var source = BuildCode(template);

            var assemblyName = "DynamicGenerated";
            var dotnetCoreDirectory = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory();
            var compilation = CSharpCompilation.Create(assemblyName).WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))
                .AddReferences(MetadataReference.CreateFromFile(typeof(object).GetTypeInfo().Assembly.Location))
                .AddReferences(MetadataReference.CreateFromFile(typeof(ProxyGenerator).GetTypeInfo().Assembly.Location))
                .AddReferences(MetadataReference.CreateFromFile(Path.Combine(dotnetCoreDirectory, "netstandard.dll")))
                .AddReferences(MetadataReference.CreateFromFile(Path.Combine(dotnetCoreDirectory, "System.Runtime.dll")));

            foreach (var type in types)
            {
                compilation = compilation.AddReferences(MetadataReference.CreateFromFile(type.GetTypeInfo().Assembly.Location));
            }
            compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source));

            using (var ms = new MemoryStream())
            {
                var result = compilation.Emit(ms);
                if (!result.Success)
                {
                    var errorMsg = result.Diagnostics[0].GetMessage();
                    Trace.TraceError(errorMsg);
                    throw new Exception(errorMsg);
                }
                return Assembly.Load(ms.GetBuffer());
            }
        }

        public static TemplateData BuildTemplate(Type[] types)
        {
            var template = new TemplateData();
            template.UsingList.Add(typeof(int).Namespace);
            template.UsingList.Add(typeof(Task).Namespace);
            template.UsingList.Add(typeof(CancellationToken).Namespace);
            template.UsingList.Add(typeof(IHttpService).Namespace);
            template.UsingList.Add(typeof(HttpServiceAttribute).Namespace);
            template.UsingList.Add(typeof(RequestDescriptionBuilderExtension).Namespace);

            foreach (var type in types)
            {
                var classTemplate = new ClassTemplate()
                {
                    SourceType = type,
                    Namespace = $"DynamicGenerated{Guid.NewGuid().ToString("n").Substring(0, 8)}",
                    Name = $"AutoGenerated{type.Name.TrimStart('I').Replace("`", string.Empty)}"
                };
                classTemplate.UsingList.Add(type.Namespace);
                foreach (var attr in CustomAttributeData.GetCustomAttributes(type))
                {
                    classTemplate.AttributeList.Add(new CustomAttributeTemplate(attr).ToString());
                }

                if (type.IsGenericType)
                {
                    foreach (var argumentType in type.GetGenericArguments())
                    {
                        var argument = new GenericArgumentTemplate()
                        {
                            Name = argumentType.Name
                        };

                        if (argumentType.GenericParameterAttributes == GenericParameterAttributes.None) continue;

                        //class约束
                        if (argumentType.GenericParameterAttributes.HasFlag(GenericParameterAttributes.ReferenceTypeConstraint))
                            argument.Constraints.Add("class");
                        //值类型约束
                        if (argumentType.GenericParameterAttributes.HasFlag(GenericParameterAttributes.NotNullableValueTypeConstraint))
                            argument.Constraints.Add("struct");

                        //类型约束
                        foreach (var constraintType in argumentType.GetGenericParameterConstraints())
                            argument.Constraints.Add(new TypeTemplate(constraintType).ToString());

                        //无参构造函数
                        if (argumentType.GenericParameterAttributes.HasFlag(GenericParameterAttributes.DefaultConstructorConstraint))
                            argument.Constraints.Add("new()");

                        classTemplate.GenericArguments.Add(argument);
                    }
                }

                //方法信息
                foreach (var method in type.GetRuntimeMethods())
                {
                    if (method.Attributes.HasFlag(MethodAttributes.SpecialName))
                        continue;
                    classTemplate.MethodList.Add(new MethodTemplate(method));
                }
                template.ClassList.Add(classTemplate);
            }
            return template;
        }

        public static string BuildCode(TemplateData template)
        {
            StringBuilder builder = new StringBuilder();
            foreach (var @using in template.UsingList)
            {
                builder.AppendFormat("using {0};", @using).AppendLine();
            }
            builder.AppendLine();
            foreach (var @class in template.ClassList)
            {
                int indentLevel = 0; //缩进字符数
                builder.Append($"namespace ").Append(@class.Namespace).AppendLine();
                builder.Append("{").AppendLine();
                indentLevel++;
                foreach (var classUsing in @class.UsingList)
                {
                    builder.AppendIndent(indentLevel).AppendFormat("using {0};", classUsing).AppendLine();
                }
                builder.AppendLine();
                //创建类
                foreach (var classAttr in @class.AttributeList)
                    builder.AppendIndent(indentLevel).Append(classAttr).AppendLine();
                builder.AppendIndent(indentLevel).Append("public class ").Append(@class.Name);
                var genericArg = string.Join(",", @class.GenericArguments.Select(x => x.Name));
                if (!string.IsNullOrEmpty(genericArg)) builder.AppendFormat("<{0}>", genericArg);
                //接口实现
                builder.Append(" : ");
                builder.Append(new TypeTemplate(@class.SourceType).Name);
                if (!string.IsNullOrEmpty(genericArg)) builder.AppendFormat("<{0}>", genericArg);
                //泛型约束
                foreach (var argument in @class.GenericArguments)
                {
                    builder.AppendFormat(" where {0} : {1}", argument.Name, string.Join(",", argument.Constraints));
                }
                builder.AppendLine();
                builder.AppendIndent(indentLevel).Append('{').AppendLine();
                indentLevel++;

                //私有字段
                builder.AppendIndent(indentLevel).Append("private readonly IRequestDescriptionBuilder _builder;").AppendLine();
                builder.AppendIndent(indentLevel).Append("private readonly IHttpClientWrapper _client;").AppendLine();
                builder.AppendLine();
                //---构造函数-----
                builder.AppendIndent(indentLevel).Append("public ").Append(@class.Name).Append("(IRequestDescriptionBuilder builder, IHttpClientWrapper client)")
                    .AppendLine();
                builder.AppendIndent(indentLevel).Append('{').AppendLine();

                indentLevel++;
                builder.AppendIndent(indentLevel).Append("_builder = builder;").AppendLine();
                builder.AppendIndent(indentLevel).Append("_client = client;").AppendLine();
                indentLevel--;
                builder.AppendIndent(indentLevel).Append('}').AppendLine();
                //--构造函数结束-----
                builder.AppendLine();
                //----方法开始----
                foreach (var method in @class.MethodList)
                {
                    builder.AppendLine();
                    builder.AppendIndent(indentLevel).Append("// ").Append(method.Name).AppendLine();
                    //方法标签
                    foreach (var methodAttr in method.AttributeList)
                        builder.AppendIndent(indentLevel).Append(methodAttr).AppendLine();

                    //方法签名
                    builder.AppendIndent(indentLevel).Append("public ");
                    if (method.IsAsync) builder.Append("async ");
                    builder.Append(method.ReturnType.ToString()).Append(" ");
                    builder.Append(method.Name);
                    if (method.GenericArguments.Count > 0)
                    {
                        builder.AppendFormat("<{0}>", string.Join(",", @class.GenericArguments.Select(x => x.Name)));
                    }
                    builder.Append("(");
                    builder.Append(string.Join(",", method.Parameters));
                    builder.Append(")").AppendLine();
                    //---方法签名结束
                    builder.AppendIndent(indentLevel).Append("{").AppendLine();
                    indentLevel++;
                    //---方法体开始-----
                    //var request = _builder.Build(typeof(ITokenService), token, template);
                    builder.AppendIndent(indentLevel).AppendFormat("var request = _builder.Build(this.GetType(),{0});", string.Join(",", method.Parameters.Select(x => x.Name)));
                    builder.AppendLine();

                    //获取token变量
                    var tokenParam = method.Method.GetParameters().LastOrDefault(x => x.ParameterType == typeof(CancellationToken));
                    var tokenName = tokenParam != null
                              ? method.Parameters.ToArray()[tokenParam.Position].Name
                              : "CancellationToken.None";

                    builder.AppendIndent(indentLevel).Append(SendCode(method.ReturnType.Type, tokenName)).AppendLine();
                    //---方法体结束-----
                    indentLevel--;
                    builder.AppendIndent(indentLevel).Append("}").AppendLine();
                }
                //--方法结束--
                indentLevel--;
                builder.AppendIndent(indentLevel).Append('}').AppendLine();
                //--类结束--
                indentLevel--;
                builder.AppendIndent(indentLevel).Append("}").AppendLine().AppendLine();
                //--命名空间结束--
            }
            var code = builder.ToString();

#if DEBUG
            var path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "generatedcode.cs");
            File.WriteAllText(path, code);
#endif
            return code;
        }

        private static string SendCode(Type returnType, string tokenName)
        {
            if (returnType == typeof(void))
                return $"_client.SendAndWrapAsync(request,{tokenName}).GetAwaiter().GetResult();";
            if (returnType == typeof(ResponseWrapper))
            {
                return $"return _client.SendAndWrapAsync(request,{tokenName}).GetAwaiter().GetResult();";
            }
            if (returnType == typeof(Task))
                return $"await _client.SendAsync(request,{tokenName});";
            if (returnType == typeof(Task<ResponseWrapper>))
                return $"return await _client.SendAndWrapAsync(request,{tokenName});";
            if (returnType.IsGenericType)
            {
                if (returnType.Namespace == typeof(ResponseWrapper<>).Namespace)
                {
                    var genericArgument = returnType.GenericTypeArguments[0];
                    var template = new TypeTemplate(genericArgument);
                    return $"return _client.SendAndWrapAsync<{template}>(request,{tokenName}).GetAwaiter().GetResult();";
                }
                if (returnType.Namespace == typeof(Task<>).Namespace)
                {
                    var genericArgument = returnType.GenericTypeArguments[0];
                    if (genericArgument.IsGenericType)
                    {
                        var argument = genericArgument.GenericTypeArguments[0];
                        if (genericArgument.Namespace == typeof(ResponseWrapper<>).Namespace)
                        {
                            var argumentTemplate = new TypeTemplate(argument);
                            return $"return await _client.SendAndWrapAsync<{argumentTemplate}>(request,{tokenName});";
                        }
                        return $"return await _client.SendAsync<{new TypeTemplate(argument)}>(request,{tokenName});";
                    }
                    var template = new TypeTemplate(genericArgument);
                    return $"return await _client.SendAsync<{template}>(request,{tokenName});";
                }
            }
            return $"return _client.SendAsync<{new TypeTemplate(returnType)}>(request,{tokenName}).GetAwaiter().GetResult();";
        }
    }

    internal static class StringBuilderExtension
    {
        public static StringBuilder AppendIndent(this StringBuilder builder, int level)
        {
            if (level <= 0) return builder;
            for (int i = 0; i < level; i++)
                builder.Append("    ");
            return builder;
        }
    }
}